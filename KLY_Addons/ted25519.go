package main

import (
        "fmt"
        "os"
//      "reflect"
        "encoding/hex"
        "github.com/coinbase/kryptology/pkg/ted25519/ted25519"

        //To retrieve keys

)

func main() {

        msg := "Hello 123"

        argCount := len(os.Args[1:])

        if argCount > 0 {
                msg = os.Args[1]
        }
        message := []byte(msg)

        config := ted25519.ShareConfiguration{T: 2, N: 3}


        // GenerateSharedKey generates a random key, splits it, and returns the public key, shares, and VSS commitments.
        //func GenerateSharedKey(config *ShareConfiguration) (PublicKey, []*KeyShare, Commitments, error)


        pub, secretShares, commitments, _ := ted25519.GenerateSharedKey(&config)

/////////////////////////////// STEP1 - prepare secretShares to export for other sides in hex format ///////////////////////////////

        //TEST VSS
        kok,_:=secretShares[0].VerifyVSS(commitments,&config)

        if kok {

                fmt.Printf(" VSS completed: %s\n",kok)

        }

// * pubkey also can be public

        // secretShares - array of 3 seeds for 3 participants. As far I know - can be generated by 1 side and distributed among other participants

        // Each party generates a nonce and we combine them together into an aggregate one
        //make .VerifyVSS to make sure it's ok https://github.com/coinbase/kryptology/blob/f7f15f217682f3e13b88846a419bce94bc3f7f73/pkg/ted25519/ted25519/keygen_test.go
        noncePub1, nonceShares1, nonceCommit1,_ := ted25519.GenerateSharedNonce(&config, secretShares[0], pub, message)
        noncePub2, nonceShares2, _, _ := ted25519.GenerateSharedNonce(&config, secretShares[1], pub, message)
        noncePub3, nonceShares3, _, _ := ted25519.GenerateSharedNonce(&config, secretShares[2], pub, message)


		//TEST nonce VSS
		//Example-user 2 received share and commitments from user1 and try to verify own share
		noncekok,_:=nonceShares1[1].VerifyVSS(nonceCommit1,&config)

		//Check other share
		noncekok2,_:=nonceShares1[0].VerifyVSS(nonceCommit1,&config)

		//Let's check if false. So,user1 received share from user2 and check with own commitments set instead of commitments of user2(nonceCommit2)
		noncekok3,_:=nonceShares2[0].VerifyVSS(nonceCommit1,&config)

		 if noncekok {
 
				fmt.Printf("Nonce VSS completed: %s\n",noncekok)
				fmt.Printf("2 Nonce VSS completed: %s\n",noncekok2)
				fmt.Printf("3 Nonce VSS completed: %s\n",noncekok3)
 
		 }

        ////////////////////////// STEP2 - prepare serialization for shares ////////////////////

        fmt.Printf("SecretShares of 1 in bytes: %s\n",hex.EncodeToString(secretShares[0].Bytes()))
        fmt.Printf("SecretShares of 2 in bytes: %s\n",hex.EncodeToString(secretShares[1].Bytes()))
        fmt.Printf("SecretShares of 3 in bytes: %s\n",hex.EncodeToString(secretShares[2].Bytes()))
        fmt.Printf(" VSS of 3 in bytes: %s\n",secretShares[2])



        //1st member
        fmt.Printf("\n\nNonceShares of 1->1 in bytes: %s\n",hex.EncodeToString(nonceShares1[0].Bytes()))
        fmt.Printf("NonceShares of 1->2 in bytes: %s\n",hex.EncodeToString(nonceShares1[1].Bytes()))
        fmt.Printf("NonceShares of 1->3 in bytes: %s\n",hex.EncodeToString(nonceShares1[2].Bytes()))
        fmt.Printf("NoncePub of 1 in bytes: %s\n",hex.EncodeToString(noncePub1.Bytes()))


        //2nd member
        fmt.Printf("\n\nNonceShares of 2->1 in bytes: %s\n",hex.EncodeToString(nonceShares2[0].Bytes()))
        fmt.Printf("NonceShares of 2->2 in bytes: %s\n",hex.EncodeToString(nonceShares2[1].Bytes()))
        fmt.Printf("NonceShares of 2->3 in bytes: %s\n",hex.EncodeToString(nonceShares2[2].Bytes()))
        fmt.Printf("NoncePub of 2 in bytes: %s\n",hex.EncodeToString(noncePub2.Bytes()))


        //3rd member
        fmt.Printf("\n\nNonceShares of 3->1 in bytes: %s\n",hex.EncodeToString(nonceShares3[0].Bytes()))
        fmt.Printf("NonceShares of 3->2 in bytes: %s\n",hex.EncodeToString(nonceShares3[1].Bytes()))
        fmt.Printf("NonceShares of 3->3 in bytes: %s\n",hex.EncodeToString(nonceShares3[2].Bytes()))
        fmt.Printf("NoncePub of 3 in bytes: %s\n",hex.EncodeToString(noncePub3.Bytes()))


        fmt.Printf("\n\nCommitments of 3: %s\n",commitments)

        //TEST DESERIALIZATION
        nonceShare33Bytes,_:=hex.DecodeString(hex.EncodeToString(nonceShares3[2].Bytes()))
        deserNonceShare:=ted25519.NonceShareFromBytes(nonceShare33Bytes)
        fmt.Printf("\n\nDESERIALIZE NonceShares of 3->3 in bytes: %s\n",deserNonceShare)


///////////////////////////// STEP3 - exchange each other with secrets //////////////////////////

        //Here wa accept shares,deserialize from hex and build such structure
        nonceShares := []*ted25519.NonceShare{
                nonceShares1[0].Add(nonceShares2[0]).Add(nonceShares3[0]),
                nonceShares1[1].Add(nonceShares2[1]).Add(nonceShares3[1]),
                nonceShares1[2].Add(nonceShares2[2]).Add(nonceShares3[2]),
        }

        //Build noncePub from all subPubs
        noncePub := ted25519.GeAdd(ted25519.GeAdd(noncePub1, noncePub2), noncePub3)

        //Build subsig
        sig1 := ted25519.TSign(message, secretShares[0], pub, nonceShares[0], noncePub)
        sig2 := ted25519.TSign(message, secretShares[1], pub, nonceShares[1], noncePub)
        sig3 := ted25519.TSign(message, secretShares[2], pub, nonceShares[2], noncePub)

        fmt.Printf("Message: %s\n", msg)
        fmt.Printf("Public key: %x\n", pub.Bytes())

        fmt.Printf("\nThreshold Sig1: %x\n", sig1.Bytes())
        fmt.Printf("Threshold Sig2: %x\n", sig2.Bytes())
        fmt.Printf("Threshold Sig3: %x\n\n", sig3.Bytes())

        sig, _ := ted25519.Aggregate([]*ted25519.PartialSignature{sig1, sig3}, &config)
        fmt.Printf("Rebuild signature with share 1 and 3: %x\n", sig)
        sig, _ = ted25519.Aggregate([]*ted25519.PartialSignature{sig2, sig3}, &config)
        fmt.Printf("Rebuild signature with share 2 and 3: %x\n", sig)

        ok, _ := ted25519.Verify(pub, message, sig)

        fmt.Printf("Signa: %s\n",hex.EncodeToString(sig))

        if ok {
                fmt.Printf("\nSignature verified\n\n")
        } else {
                fmt.Printf("\nSignature unverified\n\n")
        }

/////////////////// MY PRIVATE TEST ////////////////////////////


fmt.Printf("\nPRIVATE TEST\n\n")
//Build noncePub from 1 and 2 subPubs
noncePub12 := ted25519.GeAdd(noncePub1, noncePub2)
fmt.Printf("Public key: %x\n", noncePub12.Bytes())



}