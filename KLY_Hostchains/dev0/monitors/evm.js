/**
 * 
 * 
 *                                                            * .           ..         .           .       .           .           .
 *                                                                 .         .            .          .       .
 *                                                                       .         ..xxxxxxxxxx....               .       .             .
 *                                                               .             MWMWMWWMWMWMWMWMWMWMWMWMW                       .
 *                                                                         IIIIMWMWMWMWMWMWMWMWMWMWMWMWMWMttii:        .           .
 *                                                            .      IIYVVXMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWxx...         .           .
 *                                                                IWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMWMx..
 *                                                              IIWMWMWMWMWMWMWMWMWBY%ZACH%AND%OWENMWMWMWMWMWMWMWMWMWMWMWMWMx..        .
 *                                                               ""MWMWMWMWMWM"""""""".  .:..   ."""""MWMWMWMWMWMWMWMWMWMWMWMWMWti.
 *                                                            .     ""   . `  .: . :. : .  . :.  .  . . .  """"MWMWMWMWMWMWMWMWMWMWMWMWMti=
 *                                                                   . .   :` . :   .  .'.' '....xxxxx...,'. '   ' ."""YWMWMWMWMWMWMWMWMWMW+
 *                                                                ; . ` .  . : . .' :  . ..XXXXXXXXXXXXXXXXXXXXx.    `     . "YWMWMWMWMWMWMW
 *                                                           .    .  .  .    . .   .  ..XXXXXXXXWWWWWWWWWWWWWWWWXXXX.  .     .     """""""
 *                                                                   ' :  : . : .  ...XXXXXWWW"   W88N88@888888WWWWWXX.   .   .       . .
 *                                                              . ' .    . :   ...XXXXXXWWW"    M88N88GGGGGG888^8M "WMBX.          .   ..  :
 *                                                                    :     ..XXXXXXXXWWW"     M88888WWRWWWMW8oo88M   WWMX.     .    :    .
 *                                                                      "XXXXXXXXXXXXWW"       WN8888WWWWW  W8@@@8M    BMBRX.         .  : :
 *                                                             .       XXXXXXXX=MMWW":  .      W8N888WWWWWWWW88888W      XRBRXX.  .       .
 *                                                                ....  ""XXXXXMM::::. .        W8@889WWWWWM8@8N8W      . . :RRXx.    .
 *                                                                    ``...'''  MMM::.:.  .      W888N89999888@8W      . . ::::"RXV    .  :
 *                                                            .       ..'''''      MMMm::.  .      WW888N88888WW     .  . mmMMMMMRXx
 *                                                                 ..' .            ""MMmm .  .       WWWWWWW   . :. :,miMM"""  : ""`    .
 *                                                              .                .       ""MMMMmm . .  .  .   ._,mMMMM"""  :  ' .  :
 *                                                                          .                  ""MMMMMMMMMMMMM""" .  : . '   .        .
 *                                                                     .              .     .    .                      .         .
 *                                                           .                                         .          .         .
 *           
 * 
 * 👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️👁️‍🗨️                                                
 *
 * LINKS:[
 * 
 *         https://web3js.readthedocs.io/en/v1.2.0/web3-eth-contract.html#id36
 *         https://ethereum.stackexchange.com/questions/35997/how-to-listen-to-events-using-web3-v1-0/49472
 *         https://ethereumdev.io/listening-to-new-transactions-happening-on-the-blockchain/
 *  
 * ] 
 * 
 *                                       IMPLEMENTATION OF MONITOR FOR EVM PACK_0(via events by EVM when we push a checkpoint to some chain)
 * 
 */


/*


!MANIFEST OPTIONS:

    ?CONTRACT:"0x77D4e0dc185409B9f20f58127146692A81272799" - address of contract to grab VM logs


!REQUIRED OPTIONS TO USE MONITOR:

    ?URL:"http://youhostchainnode:<port>", - URL for node which accept RPC, API calls to query data. It might be your own node, NaaS service, "trusted" gateway, your own gateway which take info from several sources and so on

        * in some cases, URL will require some API token or smth like that. Use HTTPS only

    ?MODE:"PARANOIC" | "TRUST" - behavior for monitor. PARANOIC - you'll track hostchains on your own, block by block to make sure everything is ok. TRUST - you just ask another "trusted" instance about checkpoints

    ?CONTRACT - address of contract to track

    ?ABI - JSON'ed ABI of contract

    ?FIRST_BLOCK_FIND_STEP - step to find first block of the day


    The following options must be in section MONITORING_PRESET

        ?START_FROM - height to start to monitor from

*/




import {GET_ALL_KNOWN_PEERS} from '../../../KLY_Workflows/dev_tachyon/utils.js'
import bls from '../../../KLY_Utils/signatures/multisig/bls.js'
import {LOG} from '../../../KLY_Utils/utils.js'
import Web3 from 'web3'




//Make it global
let web3=new Web3(CONFIG.SYMBIOTE.MONITOR.URL),


GET_CONTRACT_EVENTS=async()=>{

    let {ABI,CONTRACT,TICKER} = CONFIG.SYMBIOTE.MONITOR,
    
        contractInstance = new web3.eth.Contract(ABI,CONTRACT),

        lastKnownBlockNumber = await web3.eth.getBlockNumber().catch(e=>false)


    if(lastKnownBlockNumber){

        LOG(`Found new latest known block on hostchain \x1b[35;1m${TICKER}\x1b[36;1m => \x1b[32;1m${lastKnownBlockNumber}`,'I')

        //Get from the height we stopped till the last known block
        
        let options = {
    
            fromBlock:SYMBIOTE_META.VERIFICATION_THREAD.HOSTCHAIN_MONITORING.START_FROM,

            toBlock:lastKnownBlockNumber
    
        };
    
        let events = await contractInstance.getPastEvents('Checkpoint',options).catch(e=>false)

        return [lastKnownBlockNumber,events]

    }else return []
        
},




CHECK_IF_AT_LEAST_ONE_DAY_DIFFERENCE=(timestampLater,timestampEarlier)=>{

    let startOfDayLater = new Date(timestampLater),

        startOfDayEarlier = new Date(timestampEarlier)


    startOfDayLater.setUTCHours(0, 0, 0, 0)

    startOfDayEarlier.setUTCHours(0, 0, 0, 0)


    return startOfDayLater-startOfDayEarlier >= 86400

}


/*

Checkpoint structure

Header:

{
    PAYLOAD_HASH: <32 bytes BLAKE3 HASH OF CHECKPOINT PAYLOAD. Quorum sign this hash>
    
    QUORUM_AGGREGATED_SIGNERS_PUBKEY:<48 bytes BLS AGGREGATED PUBKEY OF VALIDATORS FROM CURRENT QUORUM WHO SIGNED CHECKPOINT>

    QUORUM_AGGREGATED_SIGNATURE:<96 bytes BLS AGGREGATED SIGNATURE which verified by aggregated pubkey>

    AFK_VALIDATORS:<ARRAY OF AFK VALIDATORS FROM QUORUM WHO SKIPPED CHECKPOINT GENERATION PROCEDURE.48 BYTES PER PUBKEY>

}

If QUORUM SIZE=127 and threshold is 2/3N+1 (required by typical BFT), then count the worst case - when N/3 is AFK, malicious activity or some other problem(poor connection,fault and so on)

N/3=42

Then, the biggest possible checkpoint size is:

32 - checkpoint payload hash.
+
48 - aggregated BLS pubkey of signers
+
96 - aggregated signature
+
48*42
______________________

2192 bytes - the biggest possible checkpoint size in case QUORUM SIZE=127(validators number might be infinite)


-------------------------------------------------------------Checkpoint payload-------------------------------------------------------------

Checkpoint payload contains:

OTHER_CHECKPOINTS (KEY=>VALUE) => (SYMBIOTE_ID=>CHECKPOINT_HEADER) - object with checkpoints from other symbiotes to perform Hivemind activity

VALIDATORS_METADATA - object like this

        {
            '7GPupbq1vtKUgaqVeHiDbEJcxS7sSjwPnbht4eRaDBAEJv8ZKHNCSu2Am3CuWnHjta': {
                INDEX: -1,
                HASH: 'Poyekhali!@Y.A.Gagarin',
                BLOCKS_GENERATOR: true
            }
    
        }

    Key - BLS pubkey of validator
    Value - object to track progress to verify blocks step-by-step





*/

export default {

    GET_CHECKPOINT_FOR_GENERATION_THREAD:async()=>{

        //Receive latest valid checkpoint. If checkpoint of today includes our pubkey - then start accept blocks & share commitments due to the VALIDATORS_METADATA state in checkpoint

        let generationThreadCheckpoint = SYMBIOTE_META.GENERATION_THREAD.CHECKPOINT

        let result = await GET_CONTRACT_EVENTS()

        if(result.length!==0){

            let events = result[1]


            for(let event of events){

                //Knowing the quorum, we can step-by-step enumerate events and find the latest valid checkpoint

            }

        }

    },




    GET_CHECKPOINT_FOR_VERIFICATION_THREAD:async()=>{

        /*
        
        Reminder: Checkpoint structure

        Header:

            {
                PAYLOAD_HASH: <32 bytes BLAKE3 HASH OF CHECKPOINT PAYLOAD. Quorum sign this hash>
    
                QUORUM_AGGREGATED_SIGNERS_PUBKEY:<48 bytes BLS AGGREGATED PUBKEY OF VALIDATORS FROM CURRENT QUORUM WHO SIGNED CHECKPOINT>

                QUORUM_AGGREGATED_SIGNATURE:<96 bytes BLS AGGREGATED SIGNATURE which verified by aggregated pubkey>

                AFK_VALIDATORS:<ARRAY OF AFK VALIDATORS FROM QUORUM WHO SKIPPED CHECKPOINT GENERATION PROCEDURE.48 BYTES PER PUBKEY>

            }

            
        Payload:

            {

                PREV_CHECKPOINT_PAYLOAD_HASH

                VALIDATORS_METADATA:{
                
                    VALIDATOR_0 : {INDEX:number,HASH:string,BLOCKS_GENERATOR:bool},

                    VALIDATOR_1 : {INDEX:number,HASH:string,BLOCKS_GENERATOR:bool},

                    ...

                    VALIDATOR_N : {INDEX:number,HASH:string,BLOCKS_GENERATOR:bool}
                
                }

                OPERATIONS:{

                    Here we add/remove validators, assign to validators and so on

                }

                
                OTHER_SYMBIOTES:{

                    SYMBIOTE_ID_X: CHECKPOINTS_HEADERS_OF_OTHER_SYMBIOTES,

                    SYMBIOTE_ID_Y: CHECKPOINTS_HEADERS_OF_OTHER_SYMBIOTES,

                    ...

                }

            }

        Timestamp:number(we set the timestamp from hostchains to track days changes)

        Completed:bool(required by VERIFICATION_THREAD)



        **************************************************************************************************************

        In checkpoint on hostchain(no matter what hostchain you use) we receive raw version of checkpoint in hexademical format

        First 32 bytes - checkpoint payload hash

        Next 48 bytes - aggregated BLS pubkey of signers(it should be 2/3N+1 of current quorum)

        Next 96 bytes - aggregated signature

        The rest - splitted for 48 bytes BLS pubkeys of members whose signatures we hadn't get(due to network issues or order in cycle)


        => { hash, aggregatedPub, aggregatedSigna, afkValidators }
        
        ***************************************************************************************************************

        To verify checkpoint is valid(so we can accept it and continue verification thread):

            [+] Aggregated quorum pubkey ==== AGGREGATE(afkValidators,aggregatedPub)

            [+] QUORUM_SIZE-afkValidators >= QUORUM_SIZE(2/3N+1)

            [+] VERIFY(aggregatedPub,aggregatedSigna,hash)


        */

        let currentCheckpoint = SYMBIOTE_META.VERIFICATION_THREAD.CURRENT_CHECKPOINT,

            quorumNumber=SYMBIOTE_META.VERIFICATION_THREAD.QUORUM.length,

            majority = Math.floor(quorumNumber*(2/3))+1


        //Check if majority is not bigger than number of validators. It possible when there is small number of validators

        majority = majority > quorumNumber ? quorumNumber : majority


        //Find next checkpoint and verify signatures

        let result = await GET_CONTRACT_EVENTS()


        if(result.length!==0){

            let events = result[1], validCheckpoint

            for(let event of events){

                try{

                    if(CHECK_IF_AT_LEAST_ONE_DAY_DIFFERENCE(+event.returnValues.blocktime,currentCheckpoint.TIMESTAMP)){

                        //Knowing the quorum, we can step-by-step enumerate events and find the next valid checkpoint
    
                        let [payloadHash,aggregatedPub,aggregatedSigna,afkValidators] = event.returnValues.payload.split('@')
    
                        afkValidators = afkValidators.split('*')
    
                        //_________________________ VERIFY _________________________
    
    
                        //[+] Aggregated quorum pubkey ==== AGGREGATE(afkValidators,aggregatedPub)
                        let isEqualToRootPub = bls.aggregatePublicKeys([aggregatedPub,...afkValidators]) === SYMBIOTE_META.STUFF_CACHE.get('QUORUM_AGGREGATED_PUB')
    
                        //[+] QUORUM_SIZE-afkValidators >= QUORUM_SIZE(2/3N+1) (majority)
                        let isMajority = quorumNumber-afkValidators.length >= majority
    
                        //[+] VERIFY(aggregatedPub,aggregatedSigna,hash)
                        let signaIsOk = await bls.singleVerify(payloadHash,aggregatedPub,aggregatedSigna)
    
    
                        if(isEqualToRootPub && isMajority && signaIsOk) {
    
                            validCheckpoint = {
    
                                HEADER:{    
    
                                    PAYLOAD_HASH:payloadHash,
    
                                    QUORUM_AGGREGATED_SIGNERS_PUBKEY:aggregatedPub,
    
                                    QUORUM_AGGREGATED_SIGNATURE:aggregatedSigna,
    
                                    AFK_VALIDATORS:afkValidators
    
                                },
                            
                                PAYLOAD:{
    
                                },
    
                                TIMESTAMP:event.returnValues.blocktime,
    
                                COMPLETED:false
    
                            }
    
                            /*
                        
                            Then,find pure PAYLOAD having hash in header
                        
                            PAYLOAD IS {
    
                                PREV_PAYLOAD_HASH
    
                                VALIDATORS_METADATA:{},
    
                                OPERATIONS:{},
    
                                OTHER_SYMBIOTES:{}
    
                            }
    
                            To verify: BLAKE3(JSON.stringify(PAYLOAD)) === HASH_IN_HEADER
                        
                            */
    
                            // /get_payload_for_checkpoint/:PAYLOAD_HASH
    
                            let initURLs = [CONFIG.SYMBIOTE.GET_CHECKPOINT_PAYLOAD_URL,...GET_ALL_KNOWN_PEERS()]
    
    
                            for(let url of initURLs){
    
                                let checkpointPayload = await fetch(url+'/get_payload_for_checkpoint/'+payloadHash).then(r=>r.json()).catch(e=>false)
    
                                if(checkpointPayload && checkpointPayload.PREV_PAYLOAD_HASH === currentCheckpoint.HEADER.PAYLOAD_HASH && BLAKE3(JSON.stringify(checkpointPayload))===payloadHash){
    
                                    validCheckpoint.PAYLOAD=checkpointPayload
    
                                    break
    
                                }
    
                            }
    
    
                        }
    
                    }

                }catch(e){console.log('Error occured ',e)}
                finally {

                    if(validCheckpoint.PAYLOAD.PREV_PAYLOAD_HASH) break

                }

            }

            //Once we find - find the plaintext related to the hash of payload in checkpoint

            return validCheckpoint

        }

    }
    
}